---
name: coding-conventions
description: C#のコーディング規約とベストプラクティス。命名規則、コード設計、パフォーマンス、セキュリティの基準を提供する。C#コードの記述時、コードレビュー時、またはコード品質について確認が必要なときに使用する。
---

# Coding Conventions

C#開発における統一されたコーディング規約。

## 目的

プロジェクト全体でコードの一貫性と品質を保ち、保守性の高いC#コードを実現するための規約を提供する。

## 責任範囲

- C#のコーディング規約を提供する
- 命名規則、コード設計、パフォーマンス、セキュリティの基準を提供する
- コードが規約に準拠しているかを確認する

## 使用タイミング

以下のときに参照する：
- C#コードを記述するとき
- コードレビューを実施するとき
- コード品質や規約について確認が必要なとき

## コーディング規約

### 命名規則

#### アンダースコア接頭辞の禁止（最重要）

**すべての命名においてアンダースコア接頭辞（`_`）は厳禁とする**:

- プライベートフィールドも含め、すべての命名で禁止
- 例外なく徹底する

**理由:**
- 一貫性のある命名により、コードの可読性が向上する
- 言語機能（camelCase）で十分に区別できる
- アンダースコアプレフィックスは古い慣習であり、モダンC#では不要

#### 一般的な命名ルール

**目的と役割が明確にわかる名前を使用する**:

- 一般的でない略語は使用しない
- Boolean型は `is`、`has`、`can`、`should` を先頭に付ける
- 定数は UPPER_SNAKE_CASE
- クラス、メソッド、プロパティ、定数は PascalCase
- ローカル変数、パラメータ、プライベートフィールドは camelCase
- インターフェースは `I` + PascalCase

**理由:**
- 明確な命名により、コードの意図が理解しやすくなる
- 一貫した命名規則で、チーム全体の生産性が向上する

### コード設計

**シンプルで保守しやすいコードを書く**:

- 関数は単一責任とする
- 1つの関数は100行以内を目安とする
- ネストは最大3段階まで
- ガード節を使用し、早期リターンを徹底する
- マジックナンバーを避け、定数を使用する
- 中括弧 `{}` は省略しない（1行のステートメントでも必ず使用）
- 短い処理は1行で書く（短い条件・処理は中括弧つきで1行にまとめる）

**理由:**
- 単一責任により、関数の目的が明確になる
- 短い関数は理解しやすく、テストしやすい
- ネストレベルを制限することで、複雑性を抑える
- ガード節により、メインロジックが明確になる
- 定数により、値の意味が明確になり、変更が容易になる
- 中括弧の統一により、バグの混入を防ぐ

### コメントとドキュメンテーション

**コードの「なぜ」を記述する**:

- 「何を」ではなく「なぜ」を記述する
- TODO/FIXMEコメントは禁止 → Issueに登録する
- コメントアウトされたコードは削除する
- すべてのクラス・メソッド（非公開も含む）にドキュメンテーションコメントを付ける

**理由:**
- 「なぜ」の説明により、設計意図が理解しやすくなる
- TODOコメントは追跡されず忘れられるため、Issueで管理する
- コメントアウトされたコードは混乱を招く
- ドキュメンテーションコメントにより、APIの使い方が明確になる

### 例外処理とログ

**適切なエラーハンドリングを実施する**:

- 例外は例外的状況のみに使用する
- 例外を握りつぶさない
- 標準例外で不十分な場合はカスタム例外を作成する
- 例外クラス名は `Exception` で終わらせる
- エラー時には十分な情報をログ出力する

**理由:**
- 例外は通常のフロー制御には不適切（パフォーマンス低下）
- 握りつぶされた例外はデバッグを困難にする
- カスタム例外により、エラーの種類が明確になる

#### ログレベル

- **Debug**: 詳細な開発用情報
- **Info**: 起動、終了、重要な操作
- **Warning**: 注意すべき状況だが処理可能
- **Error**: 復旧可能なエラー
- **Critical**: システム停止を伴う重大なエラー

**理由:**
- 適切なログレベルにより、本番環境での問題調査が容易になる

### パフォーマンス

**適切なタイミングで最適化する**:

- 早すぎる最適化を避ける
- `using` によりリソース破棄を徹底する
- I/O操作は非同期で実施する

**理由:**
- 早すぎる最適化は複雑性を増し、保守性を下げる
- リソースリークを防ぐ
- 非同期I/Oにより、スレッドの効率的な利用が可能になる

### セキュリティ

**セキュアなコードを書く**:

- パスワードやAPIキーをソースに埋め込まない
- 外部入力は常にバリデーション・サニタイズを行う
- 依存関係を定期的に更新し、脆弱性を確認する

**理由:**
- 認証情報の漏洩を防ぐ
- インジェクション攻撃を防ぐ
- 既知の脆弱性からシステムを保護する

### C#スタイル

**モダンなC#の機能を活用する**:

- Nullable Reference Typesを有効化する
- 型が明確な場合は `var` を使用する
- 単純な処理には式形式メンバー（`=>`）を使用する
- 文字列補間 `$"..."` を使用する
- コレクション処理はLINQを活用する
- リソース管理にはusingステートメントまたは宣言を使用
- 不変データにはrecord型を使用する
- `async void` はイベントハンドラ以外では使用しない
- 非同期メソッドは `Task` または `ValueTask` を返す

**理由:**
- Nullable Reference Typesにより、null参照エラーを防ぐ
- varにより冗長性が減り、可読性が向上する
- 式形式メンバーにより、簡潔なコードになる
- 文字列補間により、文字列構築が読みやすくなる
- LINQにより、宣言的で読みやすいコードになる
- record型により、不変性が保証される
- `async void` はエラーハンドリングが困難

### パフォーマンス最適化

**必要に応じて高度な最適化を適用する**:

- 頻繁なメモリ操作には `Span<T>` や `Memory<T>` を検討する
- 同期的に終わることが多い非同期処理には `ValueTask` を検討する
- ループ内の文字列連結には `StringBuilder` を使用する

**理由:**
- Span/Memoryにより、ヒープアロケーションを削減できる
- ValueTaskにより、不要なアロケーションを避けられる
- StringBuilderにより、文字列連結のパフォーマンスが向上する

### 属性とアノテーション

**適切な属性を使用する**:

- 廃止予定コードには `[Obsolete]` を付与し、代替を提示する
- 必要に応じて適切な属性を使用する

**理由:**
- Obsolete属性により、移行計画が明確になる
- 属性により、コンパイラやツールが追加の検証を提供できる

### 最新機能活用

**積極的に使用するC#のモダン機能**:

- Record型
- initアクセサ
- トップレベルステートメント
- 拡張されたパターンマッチング
- fileスコープ型
- Raw文字列リテラル
- required修飾子
- プライマリコンストラクタ
- コレクション式
- 型エイリアス
- paramsコレクション
- Global using（プロジェクト合意の上）
- File-scoped namespace（プロジェクト合意の上）

**理由:**
- モダンな機能により、簡潔で読みやすいコードが書ける
- 言語の進化に追従することで、エコシステムの恩恵を受けられる
